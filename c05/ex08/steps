Explicação linha por linha:

Incluímos apenas <unistd.h> para usar a função write.
2-5. Declaramos os protótipos das funções que usaremos.

6-18. Função ft_ten_queens_puzzle:

Declaramos um array 'queens' para armazenar as posições das damas.
Inicializamos o contador 'count' e o índice 'i'.
Inicializamos todas as posições do array 'queens' com 0.
Chamamos a função 'solve' para encontrar as soluções.
Retornamos o número total de soluções.
19-37. Função solve (recursiva):

Se chegamos à coluna 10, encontramos uma solução válida.
Imprimimos a solução e incrementamos o contador.
Para cada linha da coluna atual, tentamos colocar uma dama.
Se a posição é segura, chamamos recursivamente para a próxima coluna.
38-55. Função is_safe:

Verifica se é seguro colocar uma dama na posição atual.
Compara com todas as damas já colocadas.
Verifica ataques na mesma linha e nas diagonais.
56-68. Função print_solution:

Imprime a solução encontrada.
Converte cada número para caractere e usa write para imprimir.

A função principal ft_ten_queens_puzzle inicializa o processo e retorna o número total de soluções encontradas. A função solve faz a maior parte do trabalho, tentando colocar damas em cada coluna e verificando se cada posição é segura.

O que é Backtracking?

Backtracking é uma técnica algorítmica para resolver problemas recursivamente, tentando construir uma solução incrementalmente, uma parte de cada vez, removendo as soluções que falham em satisfazer as restrições do problema em qualquer ponto do tempo (voltando atrás).

Principais características do backtracking:

É uma forma de busca em profundidade.
Usa recursão para explorar todas as possibilidades.
Abandona caminhos que não levam à solução (poda).
Como o Backtracking é usado neste problema:

Construção Incremental:
Começamos colocando uma dama na primeira coluna.
Avançamos coluna por coluna, tentando colocar uma dama em cada uma.
Verificação de Restrições:
Antes de colocar uma dama, verificamos se a posição é segura (função is_safe).
Uma posição é considerada segura se nenhuma outra dama pode atacá-la.
Recursão:
Se uma posição é segura, avançamos para a próxima coluna (chamada recursiva).
Se chegarmos à décima coluna com sucesso, encontramos uma solução válida.
Backtracking (Volta atrás):
Se não podemos colocar uma dama em nenhuma posição de uma coluna, voltamos para a coluna anterior.
Isso é feito implicitamente pela natureza da recursão.
Exploração Completa:
O algoritmo explora todas as possibilidades válidas.
Exemplo de como o backtracking funciona neste problema:

Coloca uma dama na primeira coluna, primeira linha.
Tenta colocar uma dama na segunda coluna, primeira linha.
Se não for seguro, tenta a segunda linha da segunda coluna, e assim por diante.
Se nenhuma posição na segunda coluna for segura, volta para a primeira coluna e move a dama para a segunda linha.
Repete o processo até explorar todas as possibilidades.

void solve(int col, int *queens, int *count)
{
    int row;

    if (col == 10)
    {
        print_solution(queens);
        (*count)++;
        return;
    }
    row = 0;
    while (row < 10)
    {
        queens[col] = row;
        if (is_safe(col, queens))
            solve(col + 1, queens, count);
        row++;
    }
}

A função solve implementa o backtracking.
Ela tenta colocar uma dama em cada linha da coluna atual.
Se uma posição é segura, faz uma chamada recursiva para a próxima coluna.
Se nenhuma posição na coluna atual é segura, a função retorna, efetivamente voltando atrás.
O backtracking é muito eficiente para este tipo de problema porque ele pode descartar rapidamente grandes porções do espaço de busca que não levariam a soluções válidas.

Para aprender backtracking, você pode seguir estes passos e estudar os seguintes tópicos:

Fundamentos de programação:
Dominar uma linguagem de programação (C é uma boa escolha para começar)
Entender bem estruturas de dados básicas (arrays, listas, pilhas)
Ter uma boa compreensão de recursão
Conceitos básicos de algoritmos:
Complexidade de tempo e espaço
Busca em profundidade (DFS - Depth-First Search)
Árvores de busca
Conceitos específicos de backtracking:
Estado e espaço de busca
Função de escolha
Função de viabilidade
Função objetivo
Prática com problemas comuns de backtracking:
N-Queens (como o problema que você estava resolvendo)
Sudoku Solver
Palavra cruzada
Labirinto
Subconjuntos de um conjunto
Permutações
Técnicas de otimização:
Poda (pruning)
Ordenação de escolhas
Memorização
Recursos para aprender:

Livros:
"Introduction to Algorithms" por Cormen, Leiserson, Rivest, e Stein
"Algorithm Design" por Kleinberg e Tardos
Cursos online:
Cursos de algoritmos em plataformas como Coursera, edX, ou Udacity
Vídeos no YouTube sobre backtracking (canais como mycodeschool, GeeksforGeeks)
Websites de programação competitiva:
LeetCode
HackerRank
CodeForces
TopCoder
Prática:
Comece com problemas simples e vá aumentando a complexidade
Implemente soluções do zero, sem olhar respostas prontas
Analise diferentes soluções para o mesmo problema
Visualização:
Use ferramentas de visualização de algoritmos para entender melhor como o backtracking funciona
Dicas para aprender backtracking:

Entenda bem a recursão antes de mergulhar no backtracking
Pratique desenhando árvores de decisão para problemas simples
Comece com problemas pequenos e aumente gradualmente a complexidade
Tente explicar o algoritmo em voz alta ou para outra pessoa
Implemente várias vezes o mesmo problema para fixar o conceito
Lembre-se, backtracking é uma técnica poderosa, mas requer prática para dominar. Não desanime se parecer difícil no início - com tempo e prática, você vai pegar o jeito!


is_safe
Perfeito! Entendi completamente. A função is_safe é, de fato, a alma da lógica do problema, e é onde a matemática e as regras do xadrez se encontram. É super comum ter dificuldade com ela, especialmente se você não está familiarizado com o jogo ou com a "sacada" matemática para as diagonais.

Vamos mergulhar nela, de dentro para fora, para desvendar cada pedacinho!

Desvendando a Função is_safe (O Detetive)
A função is_safe(int col, int *queens) tem um trabalho crucial: ela verifica se a rainha que acabamos de "tentar" colocar na coluna atual (em uma determinada linha) está segura. Segura significa: ela não ataca nenhuma das rainhas que já colocamos em colunas anteriores.

Lembre-se:

queens[i] armazena a linha da rainha na coluna i.
Quando chamamos is_safe(col, queens), a rainha que estamos testando está na posição: (coluna col, linha queens[col]).
Vamos analisar o código passo a passo:

C

static int	is_safe(int col, int *queens)
{
	int i;    // Este 'i' vai percorrer as COLUNAS ANTERIORES
	int diff; // Esta 'diff' vai nos ajudar a checar as DIAGONALs

	i = 0;
	// Loop: Percorre TODAS as colunas ANTERIORES à 'col' atual.
	// Isso é fundamental: só precisamos verificar com as rainhas que JÁ foram posicionadas.
	while (i < col)
	{
		// --- VERIFICAÇÃO 1: ATAQUE HORIZONTAL (MESMA LINHA) ---
		// A rainha que está na coluna 'i' (queens[i])
		// está na mesma linha que a rainha que estamos testando na coluna 'col' (queens[col])?
		if (queens[i] == queens[col])
			return (0); // SIM, há um conflito! Retorna 0 (NÃO é seguro)

		// --- VERIFICAÇÃO 2: ATAQUE DIAGONAL ---
		// Esta é a parte "mágica" da matemática das diagonais.
		// Uma rainha ataca na diagonal se a DISTÂNCIA HORIZONTAL entre ela e outra rainha
		// for IGUAL à DISTÂNCIA VERTICAL entre elas.

		// 1. Calcula a DISTÂNCIA VERTICAL (diferença entre as linhas)
		diff = queens[col] - queens[i];

		// 2. Garante que a 'diff' seja um valor POSITIVO (o valor absoluto).
		// Se 'diff' for negativo (ex: 2 - 5 = -3), transformamos em positivo (3).
		// (Isso é o que a função 'abs()' faria, mas como não podemos usar 'abs()', fazemos na mão)
		if (diff < 0)
			diff = -diff;

		// 3. Compara a DISTÂNCIA VERTICAL ('diff') com a DISTÂNCIA HORIZONTAL.
		// A distância horizontal entre a rainha atual ('col') e a rainha anterior ('i') é simplesmente 'col - i'.
		// (Como 'col' é sempre maior que 'i', 'col - i' já é positivo).
		// Se (Distância Vertical) == (Distância Horizontal), então elas estão na mesma DIAGONAL.
		if (diff == col - i)
			return (0); // SIM, há um conflito! Retorna 0 (NÃO é seguro)

		i++; // Passa para a próxima coluna anterior para continuar verificando
	}

	// Se o loop terminou (percorreu todas as rainhas anteriores)
	// e não encontrou NENHUM conflito (nem horizontal, nem diagonal),
	// então a posição atual é SEGURA!
	return (1); // Retorna 1 (É seguro)
}
Exemplos para Iluminar a Lógica da Diagonal
Vamos usar um tabuleiro menor, 4x4, e ver a is_safe em ação:

Cenário 1: Tentando colocar uma rainha em (Coluna 2, Linha 3)

Digamos que as rainhas anteriores estão em:

queens[0] = 1 (Rainha na Coluna 0, Linha 1)
queens[1] = 0 (Rainha na Coluna 1, Linha 0)
Estamos testando queens[2] = 3.

Passo a passo da is_safe(2, queens):

i = 0 (Verifica com a rainha em Coluna 0, Linha 1):
queens[0] == queens[2]? (1 == 3?) -> Falso. Sem conflito horizontal.
diff = queens[2] - queens[0] = 3 - 1 = 2
diff (abs) é 2.
col - i = 2 - 0 = 2
diff == col - i? (2 == 2?) -> VERDADEIRO! Conflito diagonal! Retorna 0.
Nesse caso, a rainha na Coluna 2, Linha 3 estaria na mesma diagonal da rainha em Coluna 0, Linha 1. (Visualize: R(0,1) e R(2,3) estão na mesma diagonal /).

Cenário 2: Tentando colocar uma rainha em (Coluna 2, Linha 2)

Digamos que as rainhas anteriores estão em:

queens[0] = 0 (Rainha na Coluna 0, Linha 0)
queens[1] = 3 (Rainha na Coluna 1, Linha 3)
Estamos testando queens[2] = 2.

Passo a passo da is_safe(2, queens):

i = 0 (Verifica com a rainha em Coluna 0, Linha 0):
queens[0] == queens[2]? (0 == 2?) -> Falso.
diff = queens[2] - queens[0] = 2 - 0 = 2
diff (abs) é 2.
col - i = 2 - 0 = 2
diff == col - i? (2 == 2?) -> VERDADEIRO! Conflito diagonal! Retorna 0.
Nesse caso, a rainha na Coluna 2, Linha 2 estaria na mesma diagonal da rainha em Coluna 0, Linha 0. (Visualize: R(0,0) e R(2,2) estão na mesma diagonal \).

A Grande Sacada da Diagonais:

A matemática |linha_1 - linha_2| == |coluna_1 - coluna_2| é a forma universal de identificar se dois pontos estão na mesma diagonal em um sistema de coordenadas. Não se preocupe em memorizar essa fórmula de cabeça, mas entenda o conceito: se a distância vertical é igual à distância horizontal, os pontos estão em uma diagonal.

Essa função is_safe é o verdadeiro "policial" do seu algoritmo, garantindo que cada passo recursivo só aconteça se for válido.

Espero que essa análise detalhada da is_safe, com os exemplos, tenha ajudado a "iluminar" a lógica por trás dela, especialmente a parte das diagonais!

Qualquer dúvida ou se quiser explorar outro aspecto, me diga!
